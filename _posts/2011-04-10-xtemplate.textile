---
layout: post
title: Linguagem XTemplate 3.0
categories: tutoriais
---


h3. Introdução

A linguagem XTemplate torna possível a especificação de componentes e relações genéricas que serão usadas em uma composição através de um template de composição. Dessa forma o usuário final precisa apenas apresentar as mídias que serão usadas na composição ficando o processador de templates responsável por criar as relações especificadas no template.


h3. Definições

*Composição*    
Elemento hipermídia cuja funcionalidade é conter outros elementos, podendo ser outras composições ou nós de mídia. Em NCL é representado pelo elemento _context_.

*Template*
Documento escrito com a linguagem XTemplate, versão 3.0.

*NCL*
Documento NCL que usa um template de composição. Este deve possuir em seu cabeçalho o elemento _templateBase_ definido ao menos um template e pelo menos uma composição referenciando o template definido.

*Processador*
Software que transforma um documento ncl usando templates em um documento completo.



h3. A Linguagem

Uma composição é aqui representada pelo nó de contexto (elemento _context_) da linguagem NCL (_Nested Context Language_). Vale lembrar que na especificação da linguagem NCL o corpo (elemento _body_) de um documento NCL é considerado também um nó de contexto, logo um template pode também ser utilizado pelo corpo do ncl.

Um *template* é definido pelo elemento _xtemplate_, esse elemento possui como atributos:
* *+id+* - define um identificador para o template;
* *name* - define um nome para o template;
* *description* - descreve o template.

Um template é definido em quatro partes, são elas, o cabeçalho (elemento _head_), o vocabulário (elemento _vocabulary_), o corpo (elemento _body_) e as restrições (elemento _constraints_).



h3. Cabeçalho

O cabeçalho (elemento _head_) do template, permite especificar bases de conectores e definições de apresentação (bases de regiões, descritores e regras) que serão importadas pelo ncl. O cabeçalho permite também que um template estenda as definições especificadas em um outro template.
                

h4. Importando Bases

A especificação das bases de conectores a serem importadas é feita através do elemento _connectorBase_, este possui como filhos elementos _importBase_.

<code>
<connectorBase>
	<importBase alias="connBase" documentURI="connectorbase.ncl"/>
</connectorBase>
</code>

A especificação das definições de apresentação (bases de regiões, descritores e regras) a serem importadas é feita através do elemento _descriptorBase_, possuindo este elementos _importBase_ como filhos.

<code>
<descriptorBase>
	<importBase alias="presBase" documentURI="descriptorbase.ncl"/>
</descriptorBase>
</code>

A importação é feita desta forma pois em NCL, um documento _A_ que importe a base de descritores de _B_, importa também as bases de regiões e regras de _B_, caso _B_ as tenha definido. Logo a linguagem XTemplate tira proveito dessa funcionalidade de forma a definir como o *ncl* deverá apresentar as mídias nele contidas.
  
O elemento _importBase_ define uma base que será importada pelo *ncl*. Este possui os seguintes atributos:
* *+alias+* - define um apelido pelo qual a base será referenciada;
* *+documentURI+* - define a localização da base.


h4. Estendendo Templates

Um *template* pode estender um ou mais *templates*. Ao fazer isso, o *template* herdará todas as definições presentes nos *templates* estendidos, a única exceção são as *constraints* que poderão ser sobrescritas para evitar inconsistências. Essa extensão é feita no cabeçalho através do elemento _extends_.

O elemento _extends_ possui os seguintes atributos:
* *+xtemplate+* - define a localização do *template* a ser estendido.
* *overwriteConstraints* - define se as constraints serão ou não sobrescritas

Vale lembrar que se um template _A_ estende um template _B_, as restrições, de _B_, caso estendidas, ainda sim deverão ser satisfeitas. Logo é necessário um maior cuidado para não se definir um *template* que seja contrário a essas restrições.



h3. Vocabulário

O vocabulário (elemento _vocabulary_) permite especificar quem estará presente na *composição*, além dos tipos de relações possíveis. Para isso o vocabulário define dois elementos, _component_ e _connector_.

h4. Componentes

Os componentes (elemento _component_) definirão quem poderá, e em que quantidade, estar presente na *composição*. O elemento _component_ possui os seguintes atributos:
* *+xlabel+* - define um rótulo pelo qual o componente será referenciado;
* *xtype* - define o tipo do componente. Este tipo é especificado em MIME, podendo assumir também os valores _context_, _switch_ caso o componente não seja um nó de mídia. Este atributo pode também assumir os tipos MIME genéricos _audio_, _text_, _image_, _video_ quando uma maior especificidade não seja necessária. No caso deste atributo não estar presente, qualquer elemento definido na *composição* será aceito, ficando o *processador* livre de conferir os tipos dos elementos;
* *descriptor* - define o descritor usado pelo componente, deve ser especificada também a base sendo utilizada no formato _base#descritor_;
* *minOccurs* - define um número mínimo de vezes que o componente estará presente na composição. O valor padrão assumido no processamento é 0;
* *maxOccurs* - define o número máximo de vezes que o componente estará presente. Este pode ser um número ou a string _unbounded_ caso o valor seja ilimitado. O valor padrão assumido no processamento é ilimitado.

Um componente pode ter outro componente como filho, caso esteja representando um contexto ou um _switch_. Um componente pode conter também  o elemento _port_, caso seja necessário representar âncoras ou nós de propriedade do componente.

O elemento _port_ possui os seguintes atributos:
* *+xlabel+* - define um rótulo para o port;
* *minOccurs* - número mínimo de ocorrências;
* *maxOccurs* - número máximo.

<code>
<component xlabel="subtitleSWITCH" type="switch">
	<component xlabel="subtitlePT" type="text/html"
				descriptor="presBase#d_legenda" maxOccurs="1"/>
	<component xlabel="subtitleEN" type="text/html"
				descriptor="presBase#d_legenda" maxOccurs="1"/>
</component>
</code>

O exemplo acima mostra a especificação de um elemento _switch_. Vale ressaltar que só são definidor os elementos filhos do switch (legendas). As regras a serem utilizadas ficam especificadas no próprio _switch_ em sua especificação no corpo do template como será visto posteriormente.

h4. Conectores

Os conectores definem os tipos de relações possíveis na *composição*. O elemento contém os seguintes atributos:
* *+src+* - localização do conector dentro de uma base de conectores (_base#conector_);
* *+xlabel+* - define um rótulo para o conector;
* *minOccurs, maxOccurs* - igual aos anteriores.


@<connector src="connBase#onBeginStartN" xlabel="L" maxOccurs="unbounded"/>@

O exemplo acima mostra a especificação do conector _onBeginStartN_.



h3. Corpo

O corpo (elemento _body_) é responsável por declarar pontos de interface (portas) da composição que usa o *template*; instâncias de componentes do vocabulário e seus pontos de interface; especificação de relacionamentos entre os componentes usando conectores e de inclusão, referenciando os tipos de componentes e conectores declarados no vocabulário ou instâncias de componentes. é possível a utilização de instruções para declaração de variáveis (elemento _variable_) e instruções para a realização de repetições (elemento _for-each_) especificadas pelo padrão XSLT na especificação de pontos de interface da composição, dos componentes, relacionamentos e elementos de controle de conteúdo (_switch_).

Os elementos _port_, _media_, _switch_, _context_ e _link_ apresentados abaixo, são definidos como em NCL. Aqui serão apresentados apenas os diferentes usos dos atributos existentes, além dos atributos adicionados.

h4. Port

O elemento _port_ é usado para a inserção de portas dentro da *composição*. Em sua definição, podem ser usadas duas abordagens.
Na identificação do nó relacionado à porta, poderá ser usado o atributo _component_ juntamente com o atributo _interface_, porém estes não conterão os identificadores do nó relacionado, e sim os rótulos dos mesmos. Alternativamente, pode-se usar o atributo _select_ para se identificar o nó relacionado através de uma expressão XPath.

Caso seja necessário (uso da porta em uma relação criada por outro template, ou restrições) uma porta poderá definir um rótulo através do atributo _xlabel_.

_RESUMINDO: atributos adicionados ao elemento _port_: xlabel e select._

h4. Media

O elemento _media_ define uma instância do vocabulário, permitindo que o *template* insira uma mídia na *composição*. Em sua definição é usado o atributo _xlabel_, de forma a identificar a que componente este elemento está relacionado. Os elementos filhos de _media_, _area_ e _property_ podem também conter o atributo _xlabel_.

O elemento *property* contém um atributo adicional chamado *select*, este contém uma expressão XPath que será avaliada durante o processamento e seu valor colocado em *value*.

_RESUMINDO: atributo adicionado ao elemento _media_: xlabel._

h4. Switch

O elemento _switch_ define uma instância do vocabulário, permitindo que o *template* insira um _switch_ na *composição*. Em sua definição foi adicionado o atributo _xlabel_ de forma a identificar a que componente do vocabulário o _switch_ está relacionado.

O _switch_ define de forma direta, as regras que serão usadas através do elemento _bindRule_. Sá poderão ser definidos um número de _bindRule_ igual ao número de filhos (do elemento _component_) definido no vocabulário. O exemplo abaixo demonstra a utilização do _switch_.

<code>
<switch id="subtitle" xlabel="subtitleSWITCH">
	<bindRule rule="presBase#rPT" constituent="subtitlePT"
				select="child::media[@xlabel='subtitlePT'][position() = 1]"/>
	<bindRule rule="presBase#rEN" constituent="subtitleEN"
				select="child::media[@xlabel='subtitleEN'][position() = 1]"/>
</switch>
</code>

Pode-se notar que o elemento _bindRule_ define o componente ao qual se relaciona pelo atributo _constituent_, referenciando o rótulo apropriado. O switch pode então definir dentro dele os elementos que este usará (estes contendo o rótulo apropriado) ou especificar uma expressão XPath através de seu atributo _select_.

_RESUMINDO: o switch referencia um componente do vocabulário pelo atributo xlabel, enquanto seus filhos bindRule referenciam o filho relacionado &agrave; regra pelo atributo constituent. O switch pode definir os elementos filhos diretamente ou uma expressão XPath que os localiza dentro da composição._

h4. Context

O elemento _context_ define uma instância do vocabulário, permitindo que o *template* insira um contexto na *composição*. O contexto *deve* definir todos os elementos filhos que este possuirá (portas, mídias e etc.) identificando-se com um rótulo já especificado no vocabulário através do seu atributo _xlabel_. Caso necessário seus elementos filhos podem também especificar um rótulo.

_RESUMINDO: o contexto deverá ser definido como será inserido. Este deve se identificar usando um rótulo e caso necessário identificar seus elementos filhos_

*Obs.: o contexto não poderá identificar um template, pois este não será processado.*

h4. Link

O elemento _link_ define um relação a ser usada na *composição*. Este deve identificar o conector a ser usado através do seu atributo _xtype_ e o rótulo do conector. O atributo _xconnector_ fica então inutilizado.

Os _bind_s do _link_ identificarão os papéis (assim como em NCL) e o(s) elemento(s) relacionados ao _bind_. A identificação do(s) elemento(s) é feita através do uso de uma expressão XPath no atributo _select_.

O exemplo abaixo demonstra a utilização do _link_.

<code>
<link xtype="L">
	<bind role="onBegin" select="child::media[@xlabel='audio']"/>
	<bind role="start" select="child::media[@xlabel='logo']"/>
</link>
</code>

Os elementos *linkParam* e *bindParam* possuem um atributo adicional chamado *select*, este contém uma expressão XPath que será avaliada durante o processamento e seu valor colocado em *value*.

_RESUMINDO: o link identificará o conector pelo atributo xtype. Seus filhos (bind) identificam os elementos participantes pelo atributo select._

h4. variable e for-each

Os elementos _variable_ e _for-each_ são usados de forma conjunta para ajudar na especificação de múltiplas instancias do vocabulário. O elemento _variable_ contém somente dois atributos, _name_ e _select_. Este elemento é usado para declara uma variável, o atributo _select_ identificando então o valor inicial da variável. Quando dentro do _for-each_ o elemento _variable_ define em seu atributo _select_ o passo da variável. O conteúdo da variável pode ser acessado usando @$nomedavariável@.

O elemento _for-each_ é utilizado para a criação de iterações. O número total de iterações é dado pelo número de elementos "encontrados" pela expressão XPath contida em seu atributo _select_. Estes elementos podem ser referenciados em uma expressão usando-se o valor @current()@. Dentro do _for-each_ podem ser definidos os elementos _port_, _link_, _area_, _property_ e _switch_. Os elementos _port_, _link_ e _switch_ definem instâncias do vocabulário utilizando ou não os elementos "encontrados" pelo _for-each_. Já _area_ e _property_ são inseridos nos elementos "encontrados".

_RESUMINDO: o elemento variable cria e identifica o passo de uma variável. O elemento for-each cria iterações no template permitindo a inserção de múltiplos componentes na composição._



h3. Restrições

As restrições (elemento _constraints_), são responsáveis pela definição de restrições adicionais a serem aplicadas sobre os elementos do vocabulário. As restrições são definidas separadamente (elemento _constraint_) contendo uma expressão na linguagem XPath retornando um valor boleano (atributo _select_) e uma definição (atributo _description_) que pode ser utilizada como mensagem de erro caso a restrição não seja satisfeita pela *composição*.